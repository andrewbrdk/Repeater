<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Repeater</title>
	<style>
		body {
			margin-left: 10%;
			margin-right: 10%;
		}
		x-repeater, x-login, x-parsing-errors, #alljobs {
			display: block;
			margin: 0 auto;
		}
		x-login[hidden], x-parsing-errors[hidden], #alljobs[hidden] {
			display: none;
		}
		h1 {
			text-align: center;
		}
		h1 a {
			color: black;
			text-decoration: none;
		}
		x-job {
			display: block;
			margin-bottom: 20px;
			overflow-x: auto;
			overflow-y: hidden;
		}
		x-job table {
			width: 100%;
		}
		x-job table th {
			font-size: 1.2em;
			font-weight: normal;
			text-align: left;
			margin-bottom: 10px;
		}
		x-job th.collapse_btn, td.collapse_btn {
			width: 2rem;
			min-width: 2rem;
			position: sticky;
			left: 0;
			background-color: white;
		}
		x-job th.task_names, td.task_names {
			width: 15rem;
			min-width: 15rem;
			position: sticky;
			left: 2rem;
			background-color: white;
			/* overflow */
			/* todo: show full names on hover */
			max-width: 15rem;
 			overflow: hidden;
 			text-overflow: ellipsis;
 			white-space: nowrap;
		}
		x-job th.states, td.states {
			vertical-align: middle;
			text-align: center;
			width: 1.2rem;
		}
		x-job [tooltip]:hover::after {
			display: block;
			white-space: pre-wrap;
			text-align: left;
			position: absolute;
			content: attr(tooltip);
			border: 1px solid black;
			background: #eee;
			padding: .25em;
			z-index: 1;
		}
		x-job th.selected, td.selected {
			border-bottom-style: solid;
			border-width: medium;
		}
		x-job th.schedule, td.schedule {
			width: 10rem;
			min-width: 10rem;
			text-align: right;
			position: sticky;
			right: 10rem;
			background-color: white;
		}
		x-job th.runnow_btn, td.runnow_btn {
			width: 5rem;
			min-width: 5rem;
			text-align: right;
			position: sticky;
			right: 5rem;
			background-color: white;
		}
		x-job th.onoff_btn, td.onoff_btn {
			width: 5rem;
			min-width: 5rem;
			text-align: right;
			position: sticky;
			right: 0;
			background-color: white;
		}
		x-job table a {
			color: black;
			text-decoration: none;
		}
		x-job[collapsed] .collapsible {
			display: none;
		}
		x-job[collapsed] tr.collapsible {
			visibility: collapse;
		}
		x-job pre.taskruninfo {
			background-color: #eee;
			font-family: courier, monospace;
			padding: 0 3px;
			display: block;
			font-size: 1.2em;
			white-space: pre-wrap;
		}
		x-login {
			display: block;
			text-align: center;
		}
		x-login form {
			display: inline-block;
			margin-left: auto;
			margin-right: auto;
			text-align: center;
		}
		x-login #invalidpassword {
			font-weight: bold;
			color: black;
		}
		x-parsing-errors {
			background-color: #eee;
		}
		x-parsing-errors pre {
			white-space: pre-wrap;
			font-family: monospace;
			padding: 0 3px;
			font-size: 1.2em;
		}
	</style>
</head>
<body>
	
<x-repeater></x-repeater>

<script>
class XRepeater extends HTMLElement {
	#jobsData = {};
	#evSrc = null;
	
	#login = null;
	#parsingErrors = null;
	#allJobs = null;

	connectedCallback() {
		this.innerHTML = `
			<h1><a href="/">Repeater</a></h1>
			<x-login></x-login>
			<x-parsing-errors></x-parsing-errors>
			<div id="alljobs"></div>
		`;
		this.#login = this.querySelector('x-login');
		this.#parsingErrors = this.querySelector('x-parsing-errors');
		this.#allJobs = this.querySelector('#alljobs');
		this.#login.hidden = true;
		this.#parsingErrors.hidden = true;
		this.#allJobs.hidden = true;
		this.addEventListener('job-change', (e) => {
			this.renderPage();
		});
		this.renderPage();
	}

	async renderPage() {
		let res = await fetch('/jobs', {credentials: 'include'});
		const statusCode = res.status;
		if (statusCode == 200) { // ok
			this.#login.hidden = true;
			this.#allJobs.hidden = false;
			let d = await res.json();
			this.renderJobs(d);
			this.#parsingErrors.renderParsingErrors();
			this.setupEventSource();
		} else if (statusCode == 401) { // unauthorized
			this.#login.hidden = false;
			this.#allJobs.hidden = true;
			this.#parsingErrors.hidden = true;
			this.closeEventSource();
		} else { // other
			this.#login.hidden = false;
			this.#allJobs.hidden = true;
			this.#parsingErrors.hidden = true;
			alert("internal error");
			this.closeEventSource();
		}
	}

	async renderJobs(jobs_data) {
		this.#jobsData = jobs_data;
		let xjobs = [];
		for await (const [jobIndex, job] of this.#jobsData['Jobs'].entries()) {
			let j = document.createElement('x-job');
			await j.init(job, jobIndex);
			//todo: match by job id
			let existing_job = this.#allJobs.querySelector(`#job${jobIndex}`);
			if (existing_job) {
				j.collapsed = existing_job.collapsed;
				j.selectedRun = existing_job.selectedRun;
				j.selectedTask = existing_job.selectedTask;
			}
			xjobs.push(j);
		}
		this.#allJobs.replaceChildren(...xjobs);
		xjobs.forEach((j, _) => {
			j.scrollLeft = j.scrollWidth;
		});
	}

	setupEventSource() {
		if (!this.#evSrc || this.#evSrc.readyState === EventSource.CLOSED) {
			this.#evSrc = new EventSource("/events");
			this.#evSrc.onmessage = (e) => {
				//todo: don't redraw the page on every event
				this.renderPage();
			};
			this.#evSrc.onerror = () => {
				console.error("EventSource connection error.");
			};
		}
	}

	closeEventSource() {
		if (this.#evSrc) {
			this.#evSrc.close();
			this.#evSrc = null;
		}
	}
}

class XLogin extends HTMLElement {
	connectedCallback() {
		this.innerHTML = `
			<form onsubmit="submitLogin(); return false;">
				<label for="password">Password:</label>
				<input type="password" id="password" name="password" required>
				<button type="button" onclick="submitLogin();">Login</button>
				<br/>
				<div id="invalidpassword" style="display: none;">Invalid Password</div>
			</form>
		`;
	}

	async submitLogin() {
		const password = document.getElementById('password').value;
		const response = await fetch('/login', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			credentials: 'include',
			body: JSON.stringify({ password }),
		});
		if (response.ok) {
			document.getElementById("invalidpassword").style.display = "none";
			renderPage();
		} else {
			document.getElementById("invalidpassword").style.display = "inline";
		}
	}
}

class XParsingErrors extends HTMLElement {
	#pre = null;

	connectedCallback() {
		this.innerHTML = `
			<h4>Jobs Parsing Errors:</h4>
			<pre></pre>
		`;
		this.#pre = this.querySelector('pre');
	}

	async renderParsingErrors() {
		let res = await fetch(`/parsingerrors`);
		let e = await res.text();
		if (e) {
			this.#pre.textContent = e;
			this.hidden = false;
		}
	}
}


class XJob extends HTMLElement {
	job = null;
	jobIndex = null;
	collapsed = true;
	selectedRun = null;
	selectedTask = null;	

	connectedCallback() {
		this.id = `job${this.jobIndex}`;
		let btn = this.querySelector('button.collapse_btn');
		if (btn) {
			btn.addEventListener('click', () => this.showHide());
		}
		btn = this.querySelector('button.runnow_btn');
		if (btn) {
			btn.addEventListener('click', () => this.runNow());
		}
		btn = this.querySelector('button.onoff_btn');
		if (btn) {
			btn.addEventListener('click', () => this.onOff());
		}
		if (this.collapsed) {
			this.setAttribute('collapsed', '');
		}
	}

	async init(job, jobIndex) {
		this.job = job;
		this.jobIndex = jobIndex;
		this.innerHTML = await this.jobHTML();	
	}
	
	async jobHTML() {
		let html = `<table>`;
		html += this.jobTableHeaderHTML();
		html += this.jobTableTasksHTML();
		html += `</table>`;
		html += await this.jobRunInfoHTML();
		return html;
	}

	jobTableHeaderHTML() {
		let showhidebtn_text = this.collapsed ? '+' : '-';
		let tooltip = null;
		let html = `
			<tr>
			<th class="collapse_btn"><button class="collapse_btn">${showhidebtn_text}</button></th>
			<th class="task_names"><strong>${this.job.Title}</strong></th>`;
		this.job.RunHistory.forEach((run, runIndex) => {
			let selected = (!this.collapsed && this.selectedRun == runIndex && this.selectedTask === null) ? 'selected' : '';
			tooltip = `Scheduled: ${this.formatDateTime(new Date(run.ScheduledTime))}`
			html += `
				<th id="job${this.jobIndex}run${runIndex}" class="states ${selected}">
				<a href="/#job${this.jobIndex}run${runIndex}" onclick="selectRun(${this.jobIndex}, ${runIndex}, null);return false;" tooltip="${tooltip}">${this.getHTMLStatus(run.Status)}</a>
				</th>`;
		});
		let next_scheduled = `<span> </span>`;
		if (this.job.OnOff) {
			tooltip = this.job.NextScheduled != "0001-01-01T00:00:00Z" ? `Scheduled: ${this.formatDateTime(new Date(this.job.NextScheduled))}` : '--';
			next_scheduled = `<span tooltip="${tooltip}">□</span>`;
		}
		html += `
			<th class="states">${next_scheduled}</th>
			<th class="fill"> </th>
			<th class="schedule">${this.job.HCron}</th>
			<th class="runnow_btn"><button class="runnow_btn">Run Now</button></th>`;
		let onoff_btn_html = ""
		if (this.job.Cron != "") {
			onoff_btn_html = `<button class="onoff_btn">${this.job.OnOff ? 'Turn Off' : 'Turn On'}</button>`;
		}
		html += `
			<th class="onoff_btn">${onoff_btn_html}</th>
			</tr>
		`;
		return html;
	}

	jobTableTasksHTML() {
		let html = ''
		let taskIndex = 0;
		this.job.Order.forEach((group, groupIdx) => {
			group.forEach((taskName) => {
				let offset = this.job.OrderProvided ? '&nbsp;&nbsp;'.repeat(groupIdx) : '';
				html += `
					<tr class="hist${this.jobIndex} collapsible">
					<td class="collapse_btn"> </td>
					<td class="task_names">${offset + taskName}</td>`;
				this.job.RunHistory.forEach((run, runIndex) => {
					let selected = (!this.collapsed && this.selectedRun == runIndex && this.selectedTask == taskIndex) ? 'selected' : '';
					html += `
						<td id="job${this.jobIndex}run${runIndex}task${taskIndex}" class="states ${selected}">
						<a href="/#job${this.jobIndex}run${runIndex}task${taskIndex}" onclick="selectRun(${this.jobIndex}, ${runIndex}, ${taskIndex});return false;">${this.getHTMLStatus(run.TasksHistory[taskIndex].Status)}</a>
						</td>`;
				});
				html += `
					<td class="states"> </td>
					<td class="fill"> </td>
					<td class="schedule"> </td>
					<td class="runnow_btn"> </td>
					<td class="onoff_btn"> </td>
					</tr>`;
				taskIndex++;
		})});
		return html;
	}

	async jobRunInfoHTML() {
		let sr = this.selected_run;
		let r = this.job.RunHistory[sr];
		const r_sch = r ? this.formatDateTime(new Date(r['ScheduledTime'])) : '';
		let html = `
			<p class="collapsible">
			Job scheduled: ${r_sch}
			<button onclick="restartSelected(${this.jobIndex}, ${sr}, null)">Restart job</button>
			<button onclick="cancelSelected(${this.jobIndex}, ${sr}, null)">Cancel job</button>
			</p>`;
		let st = this.selected_Task;
		let t = r ? r.TasksHistory[st] : null;
		const t_st = t && t['StartTime'] != "0001-01-01T00:00:00Z" ? this.formatDateTime(new Date(t['StartTime'])) : '-';
		const t_cmd = t ? t.RenderedCmd : '';
		let last_output = ''
		if (!this.collapsed && r && t) {
			last_output = await this.getTaskLastOutput(this.jobIndex, sr, st);
		}
		html += `
			<p class="collapsible">
			Task started: ${t_st}
			<button onclick="restartSelected(${this.jobIndex}, ${sr}, ${st})">Restart task</button>
			<button onclick="cancelSelected(${this.jobIndex}, ${sr}, ${st})">Cancel task</button>
			</p>
			<pre class="taskruninfo collapsible"><code>> ${t_cmd} </code>\n<samp> ${last_output} </samp>
			</pre>`;
		return html;
	}

	async selectRun(jobIndex, runIndex, taskIndex) {
		JOBS.Jobs[jobIndex].displaystate.visibility = true;
		JOBS.Jobs[jobIndex].displaystate.selected_run = runIndex;
		JOBS.Jobs[jobIndex].displaystate.selected_task = taskIndex;
		var e = document.getElementById(`job${jobIndex}`);
		let div = await jobDiv(JOBS.Jobs[jobIndex], jobIndex);
		let s = e.scrollLeft;
		e.parentNode.replaceChild(div, e);
		div.scrollLeft = s;
	}

	async onOff() {
		let res = await fetch(`/onoff?job=${this.jobIndex}`);
		this.dispatchEvent(new CustomEvent('job-change', {bubbles: true}));
	}

	async runNow() {
		let res = await fetch(`/runnow?job=${this.jobIndex}`);
		this.dispatchEvent(new CustomEvent('job-change', {bubbles: true}));
	}

	async restartSelected(job, run, task) {
		let res = await fetch(`/restart?job=${job}&run=${run}&task=${task}`);
		this.dispatchEvent(new CustomEvent('job-change', {bubbles: true}));
	}

	async cancelSelected(job, run, task) {
		let res = await fetch(`/cancel?job=${job}&run=${run}&task=${task}`);
		this.dispatchEvent(new CustomEvent('job-change', {bubbles: true}));
	}

	async getTaskLastOutput(job, run, task) {
		let res = await fetch(`/lastoutput?job=${job}&run=${run}&task=${task}`);
		let t = await res.text();
		return t;
	}

	getHTMLStatus(runStatus) {
		// "&#9632;", "&Cross;", "&#9704;" "&#9633;"
		const statusSymbols = ['■', '⨯', '◨', '□'];
		return statusSymbols[runStatus] || '?';
	}

	async showHide() {
		this.collapsed = !this.collapsed;
		this.toggleAttribute('collapsed');
		this.querySelector('button.collapse_btn').textContent = this.collapsed ? '+' : '-';
	}

	formatDateTime(d) {
		return (
			d.getDate().toString().padStart(2, '0') + "-" +
			(d.getMonth()+1).toString().padStart(2, '0') + "-" +
			d.getFullYear() + " " + 
			d.getHours().toString().padStart(2, '0') + ":" + 
			d.getMinutes().toString().padStart(2, '0') + ":" +
			d.getSeconds().toString().padStart(2, '0')
		);
	}
}
customElements.define('x-job', XJob);
customElements.define('x-parsing-errors', XParsingErrors);
customElements.define('x-login', XLogin);
customElements.define('x-repeater', XRepeater);

</script>
</body>
</html>
